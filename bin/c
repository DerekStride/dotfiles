#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/inline"
require "optparse"
require "logger"
require "json"

$stdout.sync = $stderr.sync = true

DOTFILES_DIR = File.expand_path("~/.dotfiles")
MCP_CONFIG_PATH = File.join(DOTFILES_DIR, "data", "mcp.json")
TMP_MCP_CONFIG = "/tmp/mcp.json"
DEFAULT_MCP_SERVERS = %w[gt-mcp].freeze
SKIP_PERMISSIONS_FLAG = "--allow-dangerously-skip-permissions"

def level = ENV.fetch("LOG_LEVEL", Logger::WARN)
def progname = File.basename($0)
def logger = @logger ||= Logger.new($stderr, level:, progname: 'claude')
def options = @options ||= { mcp: DEFAULT_MCP_SERVERS }
def env = @env ||= {}

gemfile do
  source "https://rubygems.org"
  gem "debug"
end

def load_mcp_config
  JSON.parse(File.read(MCP_CONFIG_PATH))
rescue Errno::ENOENT
  logger.error("MCP config not found: #{MCP_CONFIG_PATH}")
  exit(1)
rescue JSON::ParserError => e
  logger.error("Invalid JSON in MCP config: #{e.message}")
  exit(1)
end

def available_servers
  load_mcp_config.dig("mcpServers")&.keys || []
end

def select_servers_with_fzf
  servers = available_servers
  if servers.empty?
    logger.error("No MCP servers found in #{MCP_CONFIG_PATH}")
    exit(1)
  end

  IO.popen(["fzf", "--multi", "--prompt=Select MCP servers> "], "r+") do |fzf|
    fzf.puts(servers.join("\n"))
    fzf.close_write
    fzf.read.split("\n").map(&:strip).reject(&:empty?)
  end
rescue Errno::ENOENT
  logger.error("fzf not found. Install fzf or specify servers with --mcp=server1,server2")
  exit(1)
end

def resolve_server_key(key, all_servers)
  return key if all_servers.key?(key)

  suffixed = "#{key}-mcp"
  return suffixed if all_servers.key?(suffixed)

  nil
end

def write_mcp_config(server_keys)
  full_config = load_mcp_config
  all_servers = full_config["mcpServers"] || {}

  selected_servers = server_keys.each_with_object({}) do |key, hash|
    resolved = resolve_server_key(key, all_servers)
    if resolved
      hash[resolved] = all_servers[resolved]
    else
      logger.warn("Unknown MCP server: #{key}")
    end
  end

  if selected_servers.empty?
    logger.error("No valid MCP servers selected")
    exit(1)
  end

  output = { "mcpServers" => selected_servers }
  File.write(TMP_MCP_CONFIG, JSON.pretty_generate(output))
  logger.info("Wrote MCP config to #{TMP_MCP_CONFIG}")
  TMP_MCP_CONFIG
end

parser = OptionParser.new do |o|
  o.banner = "usage: #{progname} [options] [claude-code-args]"
  o.separator ""
  o.separator "Options:"

  o.on("-v", "--verbose", "Enable verbose logging") { logger.level -= 1 }

  o.on("-m", "--mcp [SERVERS]", Array, "MCP servers to enable (comma-separated, omit for fzf, 'default' for dev-mcp,gt-mcp)") do |servers|
    options[:mcp] = if servers.nil?
      :fzf
    elsif servers == %w[default]
      DEFAULT_MCP_SERVERS
    else
      servers
    end
  end

  o.on("-n", "--no-default", "Start without any MCP servers") do
    options[:mcp] = nil
  end

  o.on("-s", "--skip", "Add #{SKIP_PERMISSIONS_FLAG}") do
    options[:skip_permissions] = true
  end
end

parser.parse!

logger.debug("options=#{options}")
logger.debug("remaining args=#{ARGV}")

def main
  cmd = [
    "/opt/dev/bin/devx",
    "claude",
    "--",
    "--strict-mcp-config",
  ]

  # Handle MCP server selection
  case options[:mcp]
  when :fzf
    servers = select_servers_with_fzf
    if servers.empty?
      logger.info("No servers selected, starting without MCP")
    else
      config_path = write_mcp_config(servers)
      cmd << "--mcp-config" << config_path
      logger.info("Enabling MCP servers: #{servers.join(', ')}")
    end
  when Array
    if options[:mcp].any?
      config_path = write_mcp_config(options[:mcp])
      cmd << "--mcp-config" << config_path
      logger.info("Enabling MCP servers: #{options[:mcp].join(', ')}")
    end
  when nil
    # No --mcp flag passed, start without MCP servers
    logger.debug("No MCP servers requested")
  end

  cmd << SKIP_PERMISSIONS_FLAG if options[:skip_permissions]

  # Pass through any additional arguments
  cmd.concat(ARGV)

  # Log environment variables if in debug mode
  logger.debug("Executing: #{cmd.join(' ')}")

  # Execute with modified environment
  exec(env, *cmd)
end

main
