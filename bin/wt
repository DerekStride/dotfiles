#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/inline"
require "optparse"
require "logger"

$stdout.sync = $stderr.sync = true
def progname = File.basename($0)
def options = @options ||= {}
def logger = @logger ||= Logger.new($stderr, progname:, level: ENV.fetch("LOG_LEVEL", Logger::WARN))

gemfile do
  source "https://rubygems.org"
  gem "debug"
end

WORLD_DIR = File.expand_path("~/world")

def in_git_repo?
  system("git", "rev-parse", "--git-dir", out: File::NULL, err: File::NULL)
end

def git_root
  @git_root ||= `git rev-parse --show-toplevel 2>/dev/null`.chomp
end

def world_monorepo?
  git_root.start_with?(WORLD_DIR)
end

def tmux_window_name
  return nil unless ENV["TMUX"]

  `tmux display-message -p '#W'`.chomp
end

def worktree_list
  `git worktree list --porcelain 2>/dev/null`
    .lines
    .grep(/^worktree /)
    .map { _1.sub(/^worktree /, "").chomp }
end

def require_git!
  return if in_git_repo?

  logger.error("Not in a git repository")
  exit(1)
end

def require_fzf!
  return if system("which", "fzf", out: File::NULL, err: File::NULL)

  logger.error("fzf is required")
  exit(1)
end

def resolve_name(arg)
  name = arg || tmux_window_name
  unless name && !name.empty?
    logger.error("No worktree name provided and not in a tmux window")
    exit(1)
  end
  name
end

def cmd_new(args)
  require_git!
  name = resolve_name(args.first)

  if world_monorepo?
    cmd = "dev cd #{File.basename(Dir.pwd)} -t #{name}"
    IO.popen("pbcopy", "w") { _1.write(cmd) }
    puts "copied to clipboard: #{cmd}"
    return
  end

  worktree_path = "#{git_root}.#{name}"

  if system("git", "rev-parse", "--verify", name, out: File::NULL, err: File::NULL)
    system("git", "worktree", "add", worktree_path, name) || exit(1)
  else
    system("git", "worktree", "add", "-b", name, worktree_path) || exit(1)
  end

  Dir.chdir(worktree_path)
  exec(ENV.fetch("SHELL", "/bin/bash"))
end

def cmd_ls
  exec("git", "worktree", "list")
end

def cmd_switch
  require_git!
  require_fzf!

  current_root = git_root
  relative_path = Dir.pwd.delete_prefix(current_root)

  selected = IO.popen(["fzf", "--prompt=Select worktree: ", "--height=40%", "--reverse"], "r+") do |fzf|
    fzf.puts(worktree_list.join("\n"))
    fzf.close_write
    fzf.read.chomp
  end

  if selected.empty?
    logger.error("No worktree selected")
    exit(1)
  end

  target = "#{selected}#{relative_path}"
  if Dir.exist?(target)
    puts "Switching to: #{target}"
    Dir.chdir(target)
  else
    puts "Directory #{relative_path} doesn't exist in target worktree, switching to worktree root: #{selected}"
    Dir.chdir(selected)
  end

  exec(ENV.fetch("SHELL", "/bin/bash"))
end

def cmd_remove
  require_git!
  require_fzf!

  selected = IO.popen(["fzf", "--prompt=Select worktrees to remove: ", "--multi", "--height=40%", "--reverse"], "r+") do |fzf|
    fzf.puts(worktree_list.join("\n"))
    fzf.close_write
    fzf.read.split("\n").map(&:strip).reject(&:empty?)
  end

  if selected.empty?
    logger.error("No worktrees selected")
    exit(1)
  end

  puts "Selected worktrees for removal:"
  selected.each { puts "  #{_1}" }
  print "\nAre you sure you want to remove these worktrees? (y/N): "

  unless $stdin.gets&.strip&.match?(/^[Yy]$/)
    puts "Removal cancelled"
    return
  end

  selected.each do |worktree|
    puts "Removing worktree: #{worktree}"
    system("git", "worktree", "remove", worktree, "--force")
  end
end

parser = OptionParser.new do |o|
  o.banner = "usage: #{progname} <command> [options]"
  o.separator ""
  o.separator "Commands:"
  o.separator "  (no command)     Switch to a worktree using fzf selection (default)"
  o.separator "  new [NAME]       Create a new git worktree (uses tmux window name if NAME not provided)"
  o.separator "  ls               List all git worktrees"
  o.separator "  switch           Switch to a worktree using fzf selection"
  o.separator "  remove | rm      Remove worktrees using fzf multi-selection"
  o.separator ""
  o.separator "Options:"
  o.on("-v", "--verbose", "Enable verbose logging") { logger.level -= 1 }
end

parser.order!
command = ARGV.shift || "switch"

logger.debug("command=#{command} args=#{ARGV}")

case command
when "new"        then cmd_new(ARGV)
when "ls"         then cmd_ls
when "switch"     then cmd_switch
when "remove", "rm" then cmd_remove
when "help"       then puts parser.help
else
  logger.error("Unknown command: #{command}")
  puts parser.help
  exit(1)
end
