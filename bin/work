#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/inline"

gemfile(true, quiet: true) do
  source "https://rubygems.org"
  gem "work", path: File.expand_path("../gems/work", __dir__)
end

require "optparse"
require "logger"
require "work"

$stdout.sync = $stderr.sync = true
def progname = File.basename($0)
def logger = @logger ||= Logger.new($stderr, progname:, level: ENV.fetch("LOG_LEVEL", Logger::WARN))

def resolve_name(arg)
  name = arg || Work::Git.tmux_window_name
  unless name && !name.empty?
    logger.error("No name provided and not in a tmux window")
    exit(1)
  end
  name
end

def setup_command(dir)
  if File.exist?("/opt/dev/bin/dev")
    "dev up"
  elsif File.exist?(File.join(dir, "Gemfile"))
    "bundle install"
  end
end

def cmd_new(args)
  unless Work::Git.in_git_repo?
    logger.error("Not in a git repository")
    exit(1)
  end

  name = resolve_name(args.first)

  if Work::Tmux.window_exists?(name)
    logger.error("Window '#{name}' already exists")
    exit(1)
  end

  if Work::Git.world_monorepo?
    project = File.basename(Dir.pwd)
    Work::Tmux.create_window(name, dir: Dir.pwd)
    chain = "dev cd #{project} -t #{name} && work split -t #{name}"
    Work::Tmux.send_keys(name, chain)
    logger.info("Created world workspace '#{name}' for #{project}")
  else
    worktree_path = Work::Git.create_worktree(name)
    Work::Tmux.create_window(name, dir: worktree_path)

    setup = setup_command(worktree_path)
    chain = [setup, "work split -t #{name}"].compact.join(" && ")
    Work::Tmux.send_keys(name, chain)
    logger.info("Created workspace '#{name}' at #{worktree_path}")
  end
end

def cmd_split(args)
  split_opts = {}
  OptionParser.new do |o|
    o.on("-t", "--target NAME", "Target window name") { |t| split_opts[:target] = t }
  end.order!(args)

  Work::Tmux.split_panes(**split_opts)
end

HELP = <<~HELP
  Unified workspace tool for tmux + git worktrees

  USAGE
    #{File.basename($0)} <command> [flags]

  CORE COMMANDS
    new [NAME]     Create worktree + tmux window + setup + split
    split          Split window into 3 panes

  FLAGS
    -v, --verbose  Enable verbose output

  EXAMPLES
    $ work new my-feature
    $ work split
    $ work split -t my-feature

  LEARN MORE
    Use 'work <command> --help' for more information about a command.
HELP

NEW_HELP = <<~HELP
  Create a git worktree, tmux window, run setup, and split panes

  USAGE
    #{File.basename($0)} new [NAME] [flags]

  ARGUMENTS
    NAME           Branch/worktree name (defaults to current tmux window name)

  EXAMPLES
    $ work new my-feature
    $ work new                  # uses current tmux window name

  LEARN MORE
    Use 'work new --help' for more information.
HELP

SPLIT_HELP = <<~HELP
  Split a tmux window into 3 panes (left half, right top, right bottom)

  USAGE
    #{File.basename($0)} split [flags]

  FLAGS
    -t, --target NAME  Target window name (defaults to current window)

  EXAMPLES
    $ work split
    $ work split -t my-feature

  LEARN MORE
    Use 'work split --help' for more information.
HELP

help_requested = false

parser = OptionParser.new do |o|
  o.on("-v", "--verbose", "Enable verbose logging") { logger.level -= 1 }
  o.on("-h", "--help", "Show help for command") { help_requested = true }
end

parser.order!
command = ARGV.shift

help_requested ||= ARGV.delete("-h") || ARGV.delete("--help")

if help_requested
  case command
  when "new"   then puts NEW_HELP
  when "split" then puts SPLIT_HELP
  else puts HELP
  end
  exit(0)
end

logger.debug("command=#{command} args=#{ARGV}")

case command
when "new"   then cmd_new(ARGV)
when "split" then cmd_split(ARGV)
when "help"  then puts HELP
when nil
  puts HELP
  exit(1)
else
  logger.error("Unknown command: #{command}")
  puts HELP
  exit(1)
end
